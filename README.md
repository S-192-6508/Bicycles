<h3>Переводчик строк в код BrainF***</h3>
<h5>Пояснение к алгоритму:</h5>
<pre>Допустим имеется строка символов: abcdefgh
Если перевести даную строку в набор чисел в соответствии с таблицей ASCII, получим:
a = 97, b = 98, c = 99, d = 100, e = 101, f = 102, g = 103, h = 104
Пути решения данной задачи:
  1. Напрямую: призвести инкремент ячеек последовательно без применения цикла,
  а затем вывести все полученные значения:
<code>
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.>
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.>
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.>
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.>
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.>
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.>
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.>
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
</code>
Итого: 97 + 98 + 99 + 100 + 101 + 102 + 103 + 104 + 8 + 7 = 819 символов.
  2. с применеием цикла
Рассмотрим второй вариант:
Цикл можно применить как аналог произведения, то есть всять число, например 99 и разложить его на произведение двух чисел, накпример 33 и 3. В итоге вместо 99 "+" необходимо будет написать только 36 "+", две квадратные две угловые скобки и один "-".
<code>
+++++++++++++++++++++++++++++++++[>+++<-]
</code>
Но возникает проблема: не все символы имеют номера, которые являются простыми числами, например число 101. В этом случае можно найти число, которое будет близко к нужному, но при этом будет раскладываться на 2 числа. Для числа 101 это будет 100, в итоге надо будет ввести только 21 "+", 2 квадратные скобки, три угловые скобки и один "-".
<code>
++++++++++[>++++++++++<-]>+
</code>
Из этого следует, что не всегда лучше брать число символа, а посмотреть ещё и числа по близости. Но как выбирать эти числа, по какому критерию? Выбор осуществляется на основании расчёта цены: сумма множителей рассматриваемого оптимального числа с прибавкой разницы между требуемым и рассматриваемым числом.При этом стоит учесть что необходимо брать множители так, чтобы их сумма была как можно меньше. Например, есть число 12, его можно представить как 12*1, 6*2, 4*3. Минимальной суммой обладают 4 и 3, поэтому необходимо брать именно их. Рассмотрим на примере:
Требуемое число: 97 - простое
Рассматриваемые соседние числа: 95, 96, 98, 99.
Рассчитаем стоимости:
95: можно представить как 5 * 19 => 5 + 19 + |97 - 95| = 26
96: можно представить как 8 * 12 => 8 + 12 + |97 - 96| = 21
97: можно представить как 1 * 97 => 1 + 97 + |97 - 97| = 98
98: можно представить как 7 * 14 => 7 + 14 + |97 - 98| = 22
99: можно представить как 9 * 11 => 9 + 11 + |97 - 99| = 22
Из приведённых выше размышлений можно сделать вывод, что наиболее удачным будет выбор числа 96. Но это работает для 1 символа. а что делать со множеством? В данном случае легче всего будет использовать среднее значение. а дальше увеличить его до необходимого. 
Теперь о том, как производится увеличения значений в нескольких ячейках сразу. Можно просто смещаться по ячейкам, и увеличивать их значение на нужное значение. Например, число 70 (10 * 7) нужно записать в 4 ячейки, тогда код будет выглядеть так:
<code>
++++++++++[>+++++++>+++++++>+++++++>+++++++<<<<-]
</code>
Но зачем делать это 4 раза, когда можно записать значение в одну ячейку, а потом значение этой ячейки через цик5л распространить ещё на 4 ячейки. Здесь стоит заметить, что в данном языке нет возможности присвоить данные из одной ячейки в другую без потери данных в первой ячейке, поэтому распространение на втором шаге идёт на 4 ячейки, а не на 3. Рассмотрим на примере кода:
 <code>
++++++++++[>+++++++<-]>[>+>+>+>+<<<<-]
</code>
Данный метод не имеет смысла, если строка, введенная пользователем является 1 символом.
В итоге. получив строку, алгоритм вычисляет среднее для номерво символов этой строки в соответсвии с ASCII таблицей, затем находит оптимальное ближайшее число, записывает его в число ячеек, равноге числу символов, а потом уменьшает или увеличивает до нужного числа. 

</pre>
